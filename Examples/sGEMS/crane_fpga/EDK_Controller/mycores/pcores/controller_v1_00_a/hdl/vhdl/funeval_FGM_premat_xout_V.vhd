-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2012.2
-- Copyright (C) 2012 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;


entity funeval_FGM_premat_xout_V_core  is
    generic(READ_PORT_COUNT  : NATURAL := 1;
            WRITE_PORT_COUNT : NATURAL := 1;
            DATA_WIDTH       : NATURAL := 8;
            ADDRESS_WIDTH    : NATURAL := 8;
            WORD_COUNT       : NATURAL := 256);
    port ( ra     : in  std_logic_vector(READ_PORT_COUNT*ADDRESS_WIDTH-1 downto 0);
           ce     : in  std_logic_vector(READ_PORT_COUNT-1 downto 0);
           reset    : in  std_logic;
           clk    : in  std_logic;
           q      : out std_logic_vector(READ_PORT_COUNT*DATA_WIDTH-1 downto 0));
end entity;


architecture rtl of funeval_FGM_premat_xout_V_core is

type read_address_type is array (0 to READ_PORT_COUNT-1) of std_logic_vector(ADDRESS_WIDTH-1 downto 0);
type ram_type is array (0 to WORD_COUNT-1) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal mem: ram_type := ( 
    0 => "101010111", 1 => "000000000", 2 => "010101001", 3 => "000000000", 
    4 => "000000011", 5 => "000000000", 6 => "111111101", 7 => "000000000", 
    8 => "000000011", 9 => "000000000", 10 => "111111101", 11 => "000000000", 
    12 => "000000010", 13 => "000000000", 14 => "111111110", 15 => "000000000", 
    16 => "000000010", 17 => "000000000", 18 => "111111110", 19 => "000000000", 
    20 => "111110000", 21 => "000000000", 22 => "000010000", 23 => "000000000", 
    24 => "111110100", 25 => "000000000", 26 => "000001100", 27 => "000000000", 
    28 => "111110111", 29 => "000000000", 30 => "000001001", 31 => "000000000", 
    32 => "111111000", 33 => "000000000", 34 => "000001000", 35 => "000000000", 
    36 => "111111001", 37 => "000000000", 38 => "000000111", 39 to 40=> "000000000", 
    41 => "101010101", 42 => "000000000", 43 => "010101011", 44 => "000000000", 
    45 => "000000010", 46 => "000000000", 47 => "111111110", 48 => "000000000", 
    49 => "000000010", 50 => "000000000", 51 => "111111110", 52 => "000000000", 
    53 => "000000010", 54 => "000000000", 55 => "111111110", 56 => "000000000", 
    57 => "000000010", 58 => "000000000", 59 => "111111110", 60 => "000000000", 
    61 => "111101111", 62 => "000000000", 63 => "000010001", 64 => "000000000", 
    65 => "111110100", 66 => "000000000", 67 => "000001100", 68 => "000000000", 
    69 => "111110111", 70 => "000000000", 71 => "000001001", 72 => "000000000", 
    73 => "111111000", 74 => "000000000", 75 => "000001000", 76 => "000000000", 
    77 => "111111001", 78 => "000000000", 79 => "000000111", 80 => "000000011", 
    81 => "000000000", 82 => "111111101", 83 => "000000000", 84 => "101010110", 
    85 => "000000000", 86 => "010101010", 87 => "000000000", 88 => "000000010", 
    89 => "000000000", 90 => "111111110", 91 => "000000000", 92 => "000000010", 
    93 => "000000000", 94 => "111111110", 95 => "000000000", 96 => "000000010", 
    97 => "000000000", 98 => "111111110", 99 to 103=> "000000000", 104 => "111110100", 
    105 => "000000000", 106 => "000001100", 107 => "000000000", 108 => "111110111", 
    109 => "000000000", 110 => "000001001", 111 => "000000000", 112 => "111111000", 
    113 => "000000000", 114 => "000001000", 115 => "000000000", 116 => "111111001", 
    117 => "000000000", 118 => "000000111", 119 to 120=> "000000000", 121 => "000000010", 
    122 => "000000000", 123 => "111111110", 124 => "000000000", 125 => "101010100", 
    126 => "000000000", 127 => "010101100", 128 => "000000000", 129 => "000000010", 
    130 => "000000000", 131 => "111111110", 132 => "000000000", 133 => "000000010", 
    134 => "000000000", 135 => "111111110", 136 => "000000000", 137 => "000000010", 
    138 => "000000000", 139 => "111111110", 140 to 144=> "000000000", 145 => "111110100", 
    146 => "000000000", 147 => "000001100", 148 => "000000000", 149 => "111110111", 
    150 => "000000000", 151 => "000001001", 152 => "000000000", 153 => "111111000", 
    154 => "000000000", 155 => "000001000", 156 => "000000000", 157 => "111111001", 
    158 => "000000000", 159 => "000000111", 160 => "000000010", 161 => "000000000", 
    162 => "111111110", 163 => "000000000", 164 => "000000010", 165 => "000000000", 
    166 => "111111110", 167 => "000000000", 168 => "101010101", 169 => "000000000", 
    170 => "010101011", 171 => "000000000", 172 => "000000010", 173 => "000000000", 
    174 => "111111110", 175 => "000000000", 176 => "000000010", 177 => "000000000", 
    178 => "111111110", 179 to 187=> "000000000", 188 => "111110111", 189 => "000000000", 
    190 => "000001001", 191 => "000000000", 192 => "111111000", 193 => "000000000", 
    194 => "000001000", 195 => "000000000", 196 => "111111001", 197 => "000000000", 
    198 => "000000111", 199 to 200=> "000000000", 201 => "000000010", 202 => "000000000", 
    203 => "111111110", 204 => "000000000", 205 => "000000010", 206 => "000000000", 
    207 => "111111110", 208 => "000000000", 209 => "101010100", 210 => "000000000", 
    211 => "010101100", 212 => "000000000", 213 => "000000010", 214 => "000000000", 
    215 => "111111110", 216 => "000000000", 217 => "000000010", 218 => "000000000", 
    219 => "111111110", 220 to 228=> "000000000", 229 => "111110111", 230 => "000000000", 
    231 => "000001001", 232 => "000000000", 233 => "111111000", 234 => "000000000", 
    235 => "000001000", 236 => "000000000", 237 => "111111001", 238 => "000000000", 
    239 => "000000111", 240 => "000000010", 241 => "000000000", 242 => "111111110", 
    243 => "000000000", 244 => "000000010", 245 => "000000000", 246 => "111111110", 
    247 => "000000000", 248 => "000000010", 249 => "000000000", 250 => "111111110", 
    251 => "000000000", 252 => "101010100", 253 => "000000000", 254 => "010101100", 
    255 => "000000000", 256 => "000000010", 257 => "000000000", 258 => "111111110", 
    259 to 271=> "000000000", 272 => "111111000", 273 => "000000000", 274 => "000001000", 
    275 => "000000000", 276 => "111111001", 277 => "000000000", 278 => "000000111", 
    279 to 280=> "000000000", 281 => "000000010", 282 => "000000000", 283 => "111111110", 
    284 => "000000000", 285 => "000000010", 286 => "000000000", 287 => "111111110", 
    288 => "000000000", 289 => "000000010", 290 => "000000000", 291 => "111111110", 
    292 => "000000000", 293 => "101010011", 294 => "000000000", 295 => "010101101", 
    296 => "000000000", 297 => "000000010", 298 => "000000000", 299 => "111111110", 
    300 to 312=> "000000000", 313 => "111111000", 314 => "000000000", 315 => "000001000", 
    316 => "000000000", 317 => "111111001", 318 => "000000000", 319 => "000000111", 
    320 => "000000010", 321 => "000000000", 322 => "111111110", 323 => "000000000", 
    324 => "000000010", 325 => "000000000", 326 => "111111110", 327 => "000000000", 
    328 => "000000010", 329 => "000000000", 330 => "111111110", 331 => "000000000", 
    332 => "000000010", 333 => "000000000", 334 => "111111110", 335 => "000000000", 
    336 => "101010100", 337 => "000000000", 338 => "010101100", 339 to 355=> "000000000", 
    356 => "111111001", 357 => "000000000", 358 => "000000111", 359 to 360=> "000000000", 
    361 => "000000010", 362 => "000000000", 363 => "111111110", 364 => "000000000", 
    365 => "000000010", 366 => "000000000", 367 => "111111110", 368 => "000000000", 
    369 => "000000010", 370 => "000000000", 371 => "111111110", 372 => "000000000", 
    373 => "000000010", 374 => "000000000", 375 => "111111110", 376 => "000000000", 
    377 => "101010010", 378 => "000000000", 379 => "010101110", 380 to 396=> "000000000", 
    397 => "111111001", 398 => "000000000", 399 => "000000111" );
signal rai, rai_reg: read_address_type;
signal qi : std_logic_vector(READ_PORT_COUNT*DATA_WIDTH-1 downto 0);
begin
    -- Split read addresses
    process(ra)
        variable rat: std_logic_vector(ADDRESS_WIDTH-1 downto 0);
    begin
        for i in 0 to (READ_PORT_COUNT-1) loop
            for j in 0 to (ADDRESS_WIDTH-1) loop
                rat(j) := ra(i*ADDRESS_WIDTH+j);
            end loop;
            rai(i) <= rat;
        end loop;
    end process;

    -- guide read address using CE
    process(clk)
    begin
        if (clk'event and clk='1') then
            for i in 0 to (READ_PORT_COUNT-1) loop
                if (ce(i) = '1') then
                    rai_reg(i) <= rai(i);
                end if;
            end loop;
        end if;
    end process;

    process(rai_reg, mem)
        variable qt : std_logic_vector(DATA_WIDTH-1 downto 0);
        variable raitmp : std_logic_vector(ADDRESS_WIDTH downto 0);
        variable memidx : integer;
    begin
        for i in 0 to (READ_PORT_COUNT-1) loop
            raitmp(ADDRESS_WIDTH) := '0';
            raitmp(ADDRESS_WIDTH-1 downto 0) := rai_reg(i);
            memidx := CONV_INTEGER(raitmp);
            if (memidx >= WORD_COUNT) then
                qt := (others => '0');
            else 
                qt := mem(memidx);
            end if;
            for j in 0 to (DATA_WIDTH-1) loop
                qi(i*DATA_WIDTH+j) <= qt(j);
            end loop;
        end loop;
    end process;
    q <= qi;

end rtl;



library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;


entity funeval_FGM_premat_xout_V is
generic (
    DataWidth : integer := 9;
    AddressRange : integer := 400;
    AddressWidth : integer := 9);
port (
    address0 : in STD_LOGIC_VECTOR (AddressWidth-1 DOWNTO 0);
    ce0 : in STD_LOGIC;
    q0 : out STD_LOGIC_VECTOR (DataWidth-1 DOWNTO 0);


    reset : in STD_LOGIC;
    clk : in STD_LOGIC);
end entity funeval_FGM_premat_xout_V;


architecture struct of funeval_FGM_premat_xout_V is
    signal mem_q : STD_LOGIC_VECTOR  (1 * DataWidth - 1 DOWNTO 0);
    signal mem_ra : STD_LOGIC_VECTOR  (1 * AddressWidth - 1 DOWNTO 0);
    signal mem_ce : STD_LOGIC_VECTOR  (1 - 1 DOWNTO 0);

begin
    core_inst : entity work.funeval_FGM_premat_xout_V_core
        generic map(
            READ_PORT_COUNT => 1,
            WRITE_PORT_COUNT => 1,
            DATA_WIDTH => DataWidth,
            ADDRESS_WIDTH => AddressWidth,
            WORD_COUNT => AddressRange)
        port map(
            q => mem_q,
            ra => mem_ra,
            ce => mem_ce,
            reset => reset,
            clk => clk);


    q0 <= mem_q( 1 * DataWidth - 1 DOWNTO 0 * DataWidth);


    mem_ra <= address0;

    mem_ce(0) <= ce0;





end architecture struct;
