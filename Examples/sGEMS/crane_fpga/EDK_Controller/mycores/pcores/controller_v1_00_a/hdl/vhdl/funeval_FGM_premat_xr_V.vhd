-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2012.2
-- Copyright (C) 2012 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;


entity funeval_FGM_premat_xr_V_core  is
    generic(READ_PORT_COUNT  : NATURAL := 1;
            WRITE_PORT_COUNT : NATURAL := 1;
            DATA_WIDTH       : NATURAL := 8;
            ADDRESS_WIDTH    : NATURAL := 8;
            WORD_COUNT       : NATURAL := 256);
    port ( ra     : in  std_logic_vector(READ_PORT_COUNT*ADDRESS_WIDTH-1 downto 0);
           ce     : in  std_logic_vector(READ_PORT_COUNT-1 downto 0);
           reset    : in  std_logic;
           clk    : in  std_logic;
           q      : out std_logic_vector(READ_PORT_COUNT*DATA_WIDTH-1 downto 0));
end entity;


architecture rtl of funeval_FGM_premat_xr_V_core is

type read_address_type is array (0 to READ_PORT_COUNT-1) of std_logic_vector(ADDRESS_WIDTH-1 downto 0);
type ram_type is array (0 to WORD_COUNT-1) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal mem: ram_type := ( 
    0 => "11011000010111", 1 => "00000000000000", 2 => "00010111101011", 
    3 => "00000000000000", 4 => "00110101000001", 5 => "00100101001011", 
    6 => "11111000111011", 7 => "00000000000000", 8 => "00100111101001", 
    9 => "00000000000000", 10 => "11101011011101", 11 => "00000000000000", 
    12 => "10111111010110", 13 => "11011101110010", 14 => "00000110110110", 
    15 to 16=> "00000000000000", 17 => "11011000010010", 18 => "00000000000000", 
    19 => "11111110111001", 20 to 22=> "00000000000000", 23 => "11111010101011", 
    24 => "00000000000000", 25 => "00100111101110", 26 => "00000000000000", 
    27 => "00000001100101", 28 to 30=> "00000000000000", 31 => "00000101001111", 
    32 => "11011001000100", 33 => "00000000000000", 34 => "00010111101100", 
    35 => "00000000000000", 36 => "00110001101000", 37 => "00100101000010", 
    38 => "11111001000000", 39 => "00000000000000", 40 => "00100110111100", 
    41 => "00000000000000", 42 => "11101011001000", 43 => "00000000000000", 
    44 => "11000010101111", 45 => "11011101110000", 46 => "00000110110001", 
    47 to 48=> "00000000000000", 49 => "11011000110100", 50 => "00000000000000", 
    51 => "11111110111101", 52 to 54=> "00000000000000", 55 => "11111010101111", 
    56 => "00000000000000", 57 => "00100111001100", 58 => "00000000000000", 
    59 => "00000001011101", 60 to 62=> "00000000000000", 63 => "00000101001100", 
    64 => "11011001110001", 65 => "00000000000000", 66 => "00010111101001", 
    67 => "00000000000000", 68 => "00101110010000", 69 => "00100100110111", 
    70 => "11111001000110", 71 => "00000000000000", 72 => "00100110001111", 
    73 => "00000000000000", 74 => "11101010110101", 75 => "00000000000000", 
    76 => "11000110000111", 77 => "11011101110000", 78 => "00000110101101", 
    79 to 80=> "00000000000000", 81 => "11011001010101", 82 => "00000000000000", 
    83 => "11111111000000", 84 to 86=> "00000000000000", 87 => "11111010110011", 
    88 => "00000000000000", 89 => "00100110101011", 90 => "00000000000000", 
    91 => "00000001010101", 92 to 94=> "00000000000000", 95 => "00000101001001", 
    96 => "11011010011101", 97 => "00000000000000", 98 => "00010111100100", 
    99 => "00000000000000", 100 => "00101010111010", 101 => "00100100101011", 
    102 => "11111001001100", 103 => "00000000000000", 104 => "00100101100011", 
    105 => "00000000000000", 106 => "11101010100100", 107 => "00000000000000", 
    108 => "11001001011111", 109 => "11011101110010", 110 => "00000110101000", 
    111 to 112=> "00000000000000", 113 => "11011001110110", 114 => "00000000000000", 
    115 => "11111111000010", 116 to 118=> "00000000000000", 119 => "11111010110110", 
    120 => "00000000000000", 121 => "00100110001010", 122 => "00000000000000", 
    123 => "00000001001101", 124 to 126=> "00000000000000", 127 => "00000101000101", 
    128 => "11011011001000", 129 => "00000000000000", 130 => "00010111011101", 
    131 => "00000000000000", 132 => "00100111100101", 133 => "00100100011101", 
    134 => "11111001010001", 135 => "00000000000000", 136 => "00100100111000", 
    137 => "00000000000000", 138 => "11101010010110", 139 => "00000000000000", 
    140 => "11001100110110", 141 => "11011101110101", 142 => "00000110100100", 
    143 to 144=> "00000000000000", 145 => "11011010010111", 146 => "00000000000000", 
    147 => "11111111000100", 148 to 150=> "00000000000000", 151 => "11111010111010", 
    152 => "00000000000000", 153 => "00100101101001", 154 => "00000000000000", 
    155 => "00000001000110", 156 to 158=> "00000000000000", 159 => "00000101000010" );
signal rai, rai_reg: read_address_type;
signal qi : std_logic_vector(READ_PORT_COUNT*DATA_WIDTH-1 downto 0);
begin
    -- Split read addresses
    process(ra)
        variable rat: std_logic_vector(ADDRESS_WIDTH-1 downto 0);
    begin
        for i in 0 to (READ_PORT_COUNT-1) loop
            for j in 0 to (ADDRESS_WIDTH-1) loop
                rat(j) := ra(i*ADDRESS_WIDTH+j);
            end loop;
            rai(i) <= rat;
        end loop;
    end process;

    -- guide read address using CE
    process(clk)
    begin
        if (clk'event and clk='1') then
            for i in 0 to (READ_PORT_COUNT-1) loop
                if (ce(i) = '1') then
                    rai_reg(i) <= rai(i);
                end if;
            end loop;
        end if;
    end process;

    process(rai_reg, mem)
        variable qt : std_logic_vector(DATA_WIDTH-1 downto 0);
        variable raitmp : std_logic_vector(ADDRESS_WIDTH downto 0);
        variable memidx : integer;
    begin
        for i in 0 to (READ_PORT_COUNT-1) loop
            raitmp(ADDRESS_WIDTH) := '0';
            raitmp(ADDRESS_WIDTH-1 downto 0) := rai_reg(i);
            memidx := CONV_INTEGER(raitmp);
            if (memidx >= WORD_COUNT) then
                qt := (others => '0');
            else 
                qt := mem(memidx);
            end if;
            for j in 0 to (DATA_WIDTH-1) loop
                qi(i*DATA_WIDTH+j) <= qt(j);
            end loop;
        end loop;
    end process;
    q <= qi;

end rtl;



library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;


entity funeval_FGM_premat_xr_V is
generic (
    DataWidth : integer := 14;
    AddressRange : integer := 160;
    AddressWidth : integer := 8);
port (
    address0 : in STD_LOGIC_VECTOR (AddressWidth-1 DOWNTO 0);
    ce0 : in STD_LOGIC;
    q0 : out STD_LOGIC_VECTOR (DataWidth-1 DOWNTO 0);


    reset : in STD_LOGIC;
    clk : in STD_LOGIC);
end entity funeval_FGM_premat_xr_V;


architecture struct of funeval_FGM_premat_xr_V is
    signal mem_q : STD_LOGIC_VECTOR  (1 * DataWidth - 1 DOWNTO 0);
    signal mem_ra : STD_LOGIC_VECTOR  (1 * AddressWidth - 1 DOWNTO 0);
    signal mem_ce : STD_LOGIC_VECTOR  (1 - 1 DOWNTO 0);

begin
    core_inst : entity work.funeval_FGM_premat_xr_V_core
        generic map(
            READ_PORT_COUNT => 1,
            WRITE_PORT_COUNT => 1,
            DATA_WIDTH => DataWidth,
            ADDRESS_WIDTH => AddressWidth,
            WORD_COUNT => AddressRange)
        port map(
            q => mem_q,
            ra => mem_ra,
            ce => mem_ce,
            reset => reset,
            clk => clk);


    q0 <= mem_q( 1 * DataWidth - 1 DOWNTO 0 * DataWidth);


    mem_ra <= address0;

    mem_ce(0) <= ce0;





end architecture struct;
